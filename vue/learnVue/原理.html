<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="utf-8">
		<meta content="yes" name="apple-mobile-web-app-capable"> 
		<meta content="yes" name="apple-touch-fullscreen"> 
		<meta content="telephone=no,email=no" name="format-detection"> 	
		<meta content="yes" name="apple-mobile-web-app-capable">
		<meta content="black" name="apple-mobile-web-app-status-bar-style">
		<meta name="x5-fullscreen"content="true"/>
		<meta name="full-screen"content="yes">
		<meta name="viewport" content="initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
		<title>无标题</title>
		<style>
			*{padding:0;margin: 0;}
			dl{margin: 20px;}
			dt{line-height: 40px;}
			dd{line-height: 20px;}
		</style>
	</head>
	<body>
		<!-- 
		
			vue如何批量设置属性？
			在设置的时候不会立即更新视图，什么时候更新的？如何收集的？
			列表的元素排序怎么实现的？
			
			http://www.cnblogs.com/dh-dh/p/5606596.html
			
		 -->

		
		<!-- 属性绑定 插值绑定 -->
		<div id="mvvm">
			{{title}}
			<div>
				<p v-text="name" :class="class1 class2" v-bind:src="src" v-on:click="clickHandle" @hove="hoverHandle"></p>
				<p >{{age}}</p>
				<div >
					<ul>
						<li>{{age}}</li>
					</ul>
				</div>
			</div>
		</div>


		<script>

			/*	
			原理解读：https://segmentfault.com/a/1190000006599500


			指令类型：
			
			v-text v-html
			:class v-bind:class (src href style class 等原始属性) 
			v-on:click  @click
			
			*/
			function Compile(query,vm){
				// 1.把子节点放到一个fragment里面提高性能，元素未插入dom之前都是在内存中进行操作  react的虚拟dom应该是这个原理
				// 2.编译节点（元素节点和文本节点）
				this.$vm=vm;
				this.$root=this.isElement(query)?query:document.querySelector(query);
				this.$fragement=this.node2Fragement(this.$root);
				this.compileElement(this.$fragement);
				this.$root.append(this.$fragement);
			}

			Compile.prototype={
				isElement:function(node){
					return node&&node.nodeName&&node.nodeType!=3;
				},
				isTextNode:function(node){
					return node&&node.nodeType==3;
				},
				isDirective:function(key){
					var reg=/v\-|\:|@/;
					return reg.test(key);
				},
				isEventDirective:function(key){
					var reg=/v\-on|@/;
					return reg.test(key);
				},
				eventName:function(key){
					var regOn=/v\-on\:(.*)/;
					var regAt=/@(.*)/;
					if(regOn.test(key)){
						return key.match(regOn)[1].trim();
					}
					else if(regAt.test(key)){
						return key.match(regAt)[1].trim();
					}
				},
				dirName:function(key){
					var dirV=/v\-(.*)/;
					var dirM=/\:(.*)/;
					if(dirV.test(key)){
						var dirBind=/v\-bind\:(.*)/;
						if(dirBind.test(key)){
							return key.match(dirBind)[1].trim();
						}
						return key.match(dirV)[1].trim();
					}
					else{
						return key.match(dirM)[1].trim();
					}
					
				},
				node2Fragement:function(el){
					var fragement=document.createDocumentFragment();
					[].slice.call(el.childNodes).forEach(function(child){
						fragement.appendChild(child);
					});
					return fragement;
				},
				compileElement:function(node){
					var self=this;
					var root=node;
					var childnodes=root.childNodes;
					var reg=/\{\{(.*)\}\}/;

					[].slice.call(childnodes).forEach(function(node){
						var contentText=node.textContent;
						if(self.isElement(node)){
							self.compileAttribute(node);
						}
						if(self.isTextNode(node)&&reg.test(contentText)){
							self.compileText(node);
						}
						if(node.childNodes&&node.childNodes.length>0){
							self.compileElement(node);
						}
					});
				},
				compileAttribute:function(node){
					var self=this;
					var attrs=node.attributes;
					[].slice.call(attrs).forEach(function(attr){
						var name=attr.name;
						var exp=attr.value;
						if(self.isDirective(name)){
							if(self.isEventDirective(name)){//事件处理指令
								var eventName=self.eventName(name);
							}
							else{
								var dirName=self.dirName(name);
								compileUtil[dirName]&&compileUtil[dirName](node,self.$vm,exp);
							}
						}
					});
				},
				compileText:function(textNode){
					var text=textNode.textContent;
					var reg=/\{\{(.*)\}\}/;
					var m=text.match(reg);
					var key=m[1];
				}
			};

			var compileUtil={
				text:function(node,vm,exp){
					this.bind(node,vm,exp,"text")
				},
				html:function(node,vm,exp){
					this.bind(node,vm,exp,"html")
				},
				class:function(node,vm,exp){
					this.bind(node,vm,exp,"class")
				},
				style:function(node,vm,exp){
					this.bind(node,vm,exp,"style")
				},
				if:function(node,vm,exp){
					this.bind(node,vm,exp,"if")
				},
				show:function(node,vm,exp){
					this.bind(node,vm,exp,"show")
				},
				src:function(node,vm,exp){
					this.bind(node,vm,exp,"src")
				},
				bind:function(node,vm,exp,dir){
					console.log("dir:"+dir);
					var updateFn=updater[dir+"Updater"];
					updateFn&&updateFn(node,vm[exp]);//初始化所有的

				}
			};

			var updater={
				textUpdater:function(node,value){
					node.textContent=typeof value!=undefined?value:""
				},

			};


			// var compile=new Compile("#mvvm");




			var MVVM=function(options){
				this.$options=options;
				this.$vm=this;
				this.$el=this.$options.el;
				var data=this.$data=this.$options.data||{};
				this.$compile=new Compile(this.$options.el,this);

			}

			vm=new MVVM({
				el:"#mvvm",
				data:{
					title:"实现mvvm框架",
					name:"习大大",
					age:55
				}
			});


			
		</script>
	</body>
</html>
	